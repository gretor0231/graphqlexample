package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.26

import (
	"awesomeProject/graph/model"
	"bytes"
	"context"
	"encoding/json"
	"net/http"
)

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, title string, author string, published string) (
	*model.Book, error,
) {
	// Create a new Book object with the specified fields
	newBook := model.Book{
		Title:     title,
		Author:    author,
		Published: published,
	}

	// Convert the Book object to JSON
	jsonData, err := json.Marshal(newBook)
	if err != nil {
		return nil, err
	}

	// Send a POST request to the REST API with the JSON data
	resp, err := http.Post("http://localhost:3000/books", "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Decode the response JSON into a new Book object
	var createdBook model.Book
	err = json.NewDecoder(resp.Body).Decode(&createdBook)
	if err != nil {
		return nil, err
	}

	// Return the newly created book
	return &createdBook, nil
}

// CreateStudent is the resolver for the createStudent field.
func (r *mutationResolver) CreateStudent(
	ctx context.Context, firstname string, lastname string, age int,
) (*model.Student, error) {
	// Create a new Book object with the specified fields
	newStudent := model.Student{
		Firstname: firstname,
		Lastname:  lastname,
		Age:       age,
	}

	// Convert the Book object to JSON
	jsonData, err := json.Marshal(newStudent)
	if err != nil {
		return nil, err
	}

	// Send a POST request to the REST API with the JSON data
	resp, err := http.Post("http://localhost:3000/students", "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Decode the response JSON into a new Book object
	var createdStudent model.Student
	err = json.NewDecoder(resp.Body).Decode(&createdStudent)
	if err != nil {
		return nil, err
	}

	// Return the newly created book
	return &createdStudent, nil
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) {
	client := &http.Client{}
	req, err := http.NewRequest("GET", "http://localhost:3000/books", nil)
	if err != nil {
		return nil, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var books []*model.Book

	err = json.NewDecoder(resp.Body).Decode(&books)
	if err != nil {
		return nil, err
	}
	return books, nil
}

// Students is the resolver for the students field.
func (r *queryResolver) Students(ctx context.Context) ([]*model.Student, error) {
	client := &http.Client{}
	req, err := http.NewRequest("GET", "http://localhost:3000/students", nil)
	if err != nil {
		return nil, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var students []*model.Student

	err = json.NewDecoder(resp.Body).Decode(&students)
	if err != nil {
		return nil, err
	}
	return students, nil
}

// StudentWithBook is the resolver for the studentWithBook field.
func (r *queryResolver) StudentWithBook(ctx context.Context) ([]*model.StudentWithBook, error) {

	// Define the URLs for the two REST APIs you want to call
	url1 := "http://localhost:3000/books"
	url2 := "http://localhost:3000/students"

	// Create an HTTP client to make requests to the first API
	client1 := &http.Client{}
	req1, err := http.NewRequest("GET", url1, nil)
	if err != nil {
		return nil, err
	}
	resp1, err := client1.Do(req1)
	if err != nil {
		return nil, err
	}
	defer resp1.Body.Close()

	// Create an HTTP client to make requests to the second API
	client2 := &http.Client{}
	req2, err := http.NewRequest("GET", url2, nil)
	if err != nil {
		return nil, err
	}
	resp2, err := client2.Do(req2)
	if err != nil {
		return nil, err
	}
	defer resp2.Body.Close()

	// Parse the response from the first API into a []*model.Result
	var results1 []*model.StudentWithBook
	err = json.NewDecoder(resp1.Body).Decode(&results1)
	if err != nil {
		return nil, err
	}

	// Parse the response from the second API into a []*model.Result
	var results2 []*model.StudentWithBook
	err = json.NewDecoder(resp2.Body).Decode(&results2)
	if err != nil {
		return nil, err
	}
	// Combine the results from both APIs into a single []*model.Result
	combinedResults := append(results1, results2...)

	return combinedResults, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
